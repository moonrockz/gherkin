// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!

///|
/// ── Source ──
/// Input source with optional URI and content.
pub(all) struct Source {
  uri : String?
  data : String
} derive(Show, Eq)

///|
/// ── Location ──
/// A location in the source text.
pub(all) struct Location {
  line : Int
  column : Int?
} derive(Show, Eq)

///|
/// ── Enums ──
/// Distinguishes a Scenario from a Scenario Outline.
pub(all) enum ScenarioKind {
  SCENARIO
  SCENARIO_OUTLINE
} derive(Show, Eq)

///|
pub fn ScenarioKind::ordinal(self : ScenarioKind) -> Int {
  match self {
    SCENARIO => 0
    SCENARIO_OUTLINE => 1
  }
}

///|
pub fn ScenarioKind::from(self : Int) -> ScenarioKind {
  match self {
    0 => SCENARIO
    1 => SCENARIO_OUTLINE
    _ => panic()
  }
}

///|
/// The semantic role of a step keyword.
pub(all) enum KeywordType {
  CONTEXT
  ACTION
  OUTCOME
  CONJUNCTION
  UNKNOWN
} derive(Show, Eq)

///|
pub fn KeywordType::ordinal(self : KeywordType) -> Int {
  match self {
    CONTEXT => 0
    ACTION => 1
    OUTCOME => 2
    CONJUNCTION => 3
    UNKNOWN => 4
  }
}

///|
pub fn KeywordType::from(self : Int) -> KeywordType {
  match self {
    0 => CONTEXT
    1 => ACTION
    2 => OUTCOME
    3 => CONJUNCTION
    4 => UNKNOWN
    _ => panic()
  }
}

///|
/// ── AST records ──
/// A tag as it appears in source (name includes '@' prefix).
pub(all) struct Tag {
  location : Location
  name : String
  id : String
} derive(Show, Eq)

///|
/// A comment line in the source.
pub(all) struct Comment {
  location : Location
  text : String
} derive(Show, Eq)

///|
/// A single cell in a data table row.
pub(all) struct TableCell {
  location : Location
  value : String
} derive(Show, Eq)

///|
/// A row in a data table or examples table.
pub(all) struct TableRow {
  location : Location
  id : String
  cells : Array[TableCell]
} derive(Show, Eq)

///|
/// A doc string step argument.
pub(all) struct DocString {
  location : Location
  media_type : String?
  content : String
  delimiter : String
} derive(Show, Eq)

///|
/// A data table step argument.
pub(all) struct DataTable {
  location : Location
  rows : Array[TableRow]
} derive(Show, Eq)

///|
/// A step argument is either a DocString or a DataTable.
pub(all) enum StepArgument {
  DocString(DocString)
  DataTable(DataTable)
} derive(Show, Eq)

///|
/// A single step within a scenario or background.
pub(all) struct Step {
  location : Location
  keyword : String
  keyword_type : KeywordType
  text : String
  id : String
  argument : StepArgument?
} derive(Show, Eq)

///|
/// An examples table attached to a scenario outline.
pub(all) struct Examples {
  location : Location
  tags : Array[Tag]
  keyword : String
  name : String
  description : String
  id : String
  table_header : TableRow?
  table_body : Array[TableRow]
} derive(Show, Eq)

///|
/// A background section providing shared setup steps.
pub(all) struct Background {
  location : Location
  keyword : String
  name : String
  description : String
  id : String
  steps : Array[Step]
} derive(Show, Eq)

///|
/// A scenario (or scenario outline) within a feature or rule.
pub(all) struct Scenario {
  location : Location
  tags : Array[Tag]
  kind : ScenarioKind
  keyword : String
  name : String
  description : String
  id : String
  steps : Array[Step]
  examples : Array[Examples]
} derive(Show, Eq)

///|
/// A child element of a Rule.
pub(all) enum RuleChild {
  Background(Background)
  Scenario(Scenario)
} derive(Show, Eq)

///|
/// A rule grouping related scenarios under a business rule.
pub(all) struct Rule {
  location : Location
  tags : Array[Tag]
  keyword : String
  name : String
  description : String
  id : String
  children : Array[RuleChild]
} derive(Show, Eq)

///|
/// A child element of a Feature.
pub(all) enum FeatureChild {
  Background(Background)
  Scenario(Scenario)
  Rule(Rule)
} derive(Show, Eq)

///|
/// A feature, the top-level structural element in a Gherkin document.
pub(all) struct Feature {
  location : Location
  tags : Array[Tag]
  language : String
  keyword : String
  name : String
  description : String
  children : Array[FeatureChild]
} derive(Show, Eq)

///|
/// The root of a parsed Gherkin document.
pub(all) struct GherkinDocument {
  source : Source
  feature : Feature?
  comments : Array[Comment]
} derive(Show, Eq)

///|
/// ── Parse errors ──
/// A parse error with location information.
pub(all) struct ParseError {
  message : String
  line : Int
  column : Int?
} derive(Show, Eq)

///|
/// ── Token types (record wrappers for variant payloads) ──
pub(all) struct FeatureLineData {
  location : Location
  keyword : String
  name : String
} derive(Show, Eq)

///|
pub(all) struct RuleLineData {
  location : Location
  keyword : String
  name : String
} derive(Show, Eq)

///|
pub(all) struct BackgroundLineData {
  location : Location
  keyword : String
  name : String
} derive(Show, Eq)

///|
pub(all) struct ScenarioLineData {
  location : Location
  keyword : String
  name : String
  kind : ScenarioKind
} derive(Show, Eq)

///|
pub(all) struct ExamplesLineData {
  location : Location
  keyword : String
  name : String
} derive(Show, Eq)

///|
pub(all) struct StepLineData {
  location : Location
  keyword : String
  keyword_type : KeywordType
  text : String
} derive(Show, Eq)

///|
pub(all) struct DocStringSeparatorData {
  location : Location
  delimiter : String
  media_type : String?
} derive(Show, Eq)

///|
pub(all) struct TokenTableRowData {
  location : Location
  cells : Array[String]
} derive(Show, Eq)

///|
pub(all) struct TagLineData {
  location : Location
  tags : Array[String]
} derive(Show, Eq)

///|
pub(all) struct CommentLineData {
  location : Location
  text : String
} derive(Show, Eq)

///|
pub(all) struct LanguageData {
  location : Location
  language : String
} derive(Show, Eq)

///|
pub(all) struct OtherLineData {
  location : Location
  text : String
} derive(Show, Eq)

///|
/// A token produced by the lexer, representing a classified source line.
pub(all) enum Token {
  FeatureLine(FeatureLineData)
  RuleLine(RuleLineData)
  BackgroundLine(BackgroundLineData)
  ScenarioLine(ScenarioLineData)
  ExamplesLine(ExamplesLineData)
  StepLine(StepLineData)
  DocStringSeparator(DocStringSeparatorData)
  TokenTableRow(TokenTableRowData)
  TagLine(TagLineData)
  CommentLine(CommentLineData)
  Language(LanguageData)
  Empty(Location)
  Other(OtherLineData)
  Eof(Location)
} derive(Show, Eq)

///|
/// ── Event types ──
pub(all) struct FeatureEvent {
  location : Location
  tags : Array[Tag]
  language : String
  keyword : String
  name : String
  description : String
} derive(Show, Eq)

///|
pub(all) struct RuleEvent {
  location : Location
  tags : Array[Tag]
  keyword : String
  name : String
  description : String
} derive(Show, Eq)

///|
pub(all) struct BackgroundEvent {
  location : Location
  keyword : String
  name : String
  description : String
} derive(Show, Eq)

///|
pub(all) struct ScenarioEvent {
  location : Location
  tags : Array[Tag]
  kind : ScenarioKind
  keyword : String
  name : String
  description : String
} derive(Show, Eq)

///|
pub(all) struct StepEvent {
  location : Location
  keyword : String
  keyword_type : KeywordType
  text : String
} derive(Show, Eq)

///|
pub(all) struct DocStringEvent {
  location : Location
  media_type : String?
  content : String
  delimiter : String
} derive(Show, Eq)

///|
pub(all) struct DataTableEvent {
  location : Location
  rows : Array[TableRow]
} derive(Show, Eq)

///|
pub(all) struct ExamplesEvent {
  location : Location
  tags : Array[Tag]
  keyword : String
  name : String
  description : String
  table_header : TableRow?
  table_body : Array[TableRow]
} derive(Show, Eq)

///|
pub(all) struct TagEvent {
  location : Location
  name : String
} derive(Show, Eq)

///|
pub(all) struct CommentEvent {
  location : Location
  text : String
} derive(Show, Eq)

///|
/// Events emitted during pull-based parsing.
pub(all) enum GherkinEvent {
  DocumentStart
  DocumentEnd
  FeatureStart(FeatureEvent)
  FeatureEnd
  RuleStart(RuleEvent)
  RuleEnd
  BackgroundStart(BackgroundEvent)
  BackgroundEnd
  ScenarioStart(ScenarioEvent)
  ScenarioEnd
  Step(StepEvent)
  DocString(DocStringEvent)
  DataTable(DataTableEvent)
  Examples(ExamplesEvent)
  Tag(TagEvent)
  Comment(CommentEvent)
} derive(Show, Eq)
